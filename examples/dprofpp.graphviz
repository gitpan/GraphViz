#!/usr/local/bin/perl
#
# This is a replacement for Devel::DProf's dproffpp,
# which instead produces a graph from the tmon.out
# file.
#
# Example usage:
#   perl -d:DProf test.pl
#   dprofpp.graphviz tmon.out > tmon.png

use strict;
use lib '..';
use GraphViz;

1 until <> eq "PART2\n";

my %package; 
my %subroutine;
my %name;

my %calls;
my %call_tree;

my @stack = (-1);
$package{-1} = 'main';
$subroutine{-1} = 'main';
$name{-1} = 'main::main';

while (defined(my $line = <>)) {
  chomp $line;

  if (my($id, $package, $subroutine) = $line =~ m/^& (.+?) (.+?) (.+?)$/) {
    my $name = "$package::$subroutine";
    $name{$id} = $package . '::' . $subroutine;
    $package{$id} = $package;
    $subroutine{$id} = $subroutine;
  } elsif (my($id) = $line =~ m/^\+ (.+?)$/) {
    $calls{$id}++;
    $call_tree{$stack[-1]}{$id}++;
    push @stack, $id;
  } elsif (my($id) = $line =~ m/^\- (.+?)$/) {
    die "Pop problem!" unless $id = pop @stack;
  }
}

die "Stack not empty: (" . (join ', ', @stack) . ')!' if @stack > 1;

my $g = GraphViz->new;

my %traversed;

traverse(-1);

sub traverse {
  my $id = shift;
  return if $traversed{$id}++;

  $g->add_node({ name => $name{$id}, label => $subroutine{$id}, cluster => $package{$id} });

  my @called = grep { ignore($_) } (sort keys %{$call_tree{$id}}); 
  
  foreach my $called_id (@called) {
    traverse($called_id);
    my $count = $call_tree{$id}{$called_id}; 
    $count = "" if $count == 1;
    $g->add_edge({ from => $name{$id}, to => $name{$called_id}, label => $count });
  }
}

#print $g->_as_debug;
print $g->as_png;

sub ignore {
  my $id = shift;
  return 0 if $subroutine{$id} eq 'BEGIN';
  return 0 if $subroutine{$id} eq 'END';
  return 1;
}